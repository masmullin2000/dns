{% extends "base.html" %}

{% block title %}Edit Local Network{% endblock %}

{% block content %}
<div class="table-container">
    <h2>Edit Local Network</h2>

    <p class="local-network-description">
        Define hostname to IP address mappings for your local network.
    </p>

    <h3>Add New Entry</h3>
    <form id="add-entry-form" hx-post="/edit/local_network/save" hx-target="#table-container" hx-swap="innerHTML">
        <div class="responsive-table-wrapper table-container">
        <table class="local-network-add-form">
        <colgroup>
            <col class="col-hostname">
            <col class="col-ip">
            <col class="col-action-single">
            <col class="col-action-single">
        </colgroup>
        <thead>
            <tr>
                <th class="col-hostname table-cell">Hostname</th>
                <th class="col-ip table-cell">IP Address</th>
                <th colspan="2" class="col-action-single table-cell action-col">Action</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td class="col-hostname table-cell">
                    <input type="text" name="hostname" placeholder="Enter hostname" required>
                </td>
                <td class="col-ip table-cell">
                    <input type="text" name="ip" placeholder="Enter IP address" required>
                </td>
                <td colspan="2" class="col-action-single table-cell action-col">
                    <button type="submit" class="btn">Add</button>
                </td>
            </tr>
        </tbody>
    </table>
        </div>
    </form>

    <h3>Current Entries</h3>
    <div id="table-container">
        {% include "local_network_table.html" %}
    </div>

<div class="tips-box">
    <strong>Tips:</strong>
    <ul>
        <li>Hostname can be any valid DNS name (e.g., <code>router</code>, <code>nas</code>, <code>workstation</code>)</li>
        <li>IP Address must be a valid IPv4 or IPv6 address</li>
        <li>Use the "Add Entry" button to create new mappings</li>
        <li>Use "Remove" to delete unwanted entries</li>
    </ul>
</div>
</div>

<script>
// Ensure script runs after DOM is ready
document.addEventListener('DOMContentLoaded', function() {
    // Listen for HTMX after swap to reset the form
    document.body.addEventListener('htmx:afterSwap', function(event) {
        if (event.detail.target.id === 'table-container') {
            const form = document.getElementById('add-entry-form');
            if (form) {
                form.reset();
            }
        }
    });
});

let sortState = {
    column: null,
    ascending: true
};

function toggleEdit(button, oldHostname) {
    const row = button.closest('tr');
    const displayValues = row.querySelectorAll('.display-value');
    const editInputs = row.querySelectorAll('.edit-input');
    const removeBtn = row.querySelector('.remove-btn');
    const cancelBtn = row.querySelector('.cancel-btn');
    const isEditing = button.textContent === 'Save';

    if (isEditing) {
        // Save mode - submit via HTMX
        const newHostname = editInputs[0].value.trim();
        const newIp = editInputs[1].value.trim();

        if (!newHostname || !newIp) {
            alert('Hostname and IP address cannot be empty');
            return;
        }

        // Use HTMX to submit the update
        htmx.ajax('POST', '/edit/local_network/update', {
            target: '#table-container',
            swap: 'innerHTML',
            values: {
                old_hostname: oldHostname,
                new_hostname: newHostname,
                new_ip: newIp
            }
        });
    } else {
        // Edit mode - show inputs, hide displays
        displayValues.forEach((span, index) => {
            span.style.display = 'none';
            editInputs[index].style.display = 'block';
        });

        // Change Edit button to Save
        button.textContent = 'Save';

        // Toggle Remove/Cancel buttons
        removeBtn.style.display = 'none';
        cancelBtn.style.display = 'inline-block';
    }
}

function cancelEdit(button) {
    const row = button.closest('tr');
    const displayValues = row.querySelectorAll('.display-value');
    const editInputs = row.querySelectorAll('.edit-input');
    const editSaveBtn = row.querySelector('.edit-save-btn');
    const removeBtn = row.querySelector('.remove-btn');
    const cancelBtn = row.querySelector('.cancel-btn');

    // Reset to original values
    const originalHostname = row.querySelector('[data-hostname]').getAttribute('data-hostname');
    const originalIp = row.querySelector('[data-ip]').getAttribute('data-ip');

    editInputs[0].value = originalHostname;
    editInputs[1].value = originalIp;

    // Hide inputs, show displays
    displayValues.forEach(span => span.style.display = 'inline');
    editInputs.forEach(input => input.style.display = 'none');

    // Change Save button back to Edit
    editSaveBtn.textContent = 'Edit';

    // Toggle Cancel/Remove buttons
    cancelBtn.style.display = 'none';
    removeBtn.style.display = 'inline-block';
}

function sortTable(sortBy) {
    const tbody = document.getElementById('entries-tbody');
    if (!tbody) return; // Guard against missing element

    const rows = Array.from(tbody.querySelectorAll('tr'));

    // Toggle sort direction if clicking the same column
    if (sortState.column === sortBy) {
        sortState.ascending = !sortState.ascending;
    } else {
        sortState.column = sortBy;
        sortState.ascending = true;
    }

    rows.sort((a, b) => {
        let aValue, bValue;

        if (sortBy === 'hostname') {
            aValue = a.querySelector('[data-hostname]').getAttribute('data-hostname').toLowerCase();
            bValue = b.querySelector('[data-hostname]').getAttribute('data-hostname').toLowerCase();

            const result = aValue.localeCompare(bValue);
            return sortState.ascending ? result : -result;
        } else if (sortBy === 'ip') {
            aValue = a.querySelector('[data-ip]').getAttribute('data-ip');
            bValue = b.querySelector('[data-ip]').getAttribute('data-ip');

            // Convert IPs to comparable format
            const ipToNum = (ip) => {
                const parts = ip.split('.');
                if (parts.length === 4) {
                    // IPv4
                    return parts.reduce((acc, part) => acc * 256 + parseInt(part), 0);
                } else {
                    // IPv6 or other - use string comparison
                    return ip;
                }
            };

            const aNum = ipToNum(aValue);
            const bNum = ipToNum(bValue);

            let result;
            if (typeof aNum === 'number' && typeof bNum === 'number') {
                result = aNum - bNum;
            } else {
                result = String(aNum).localeCompare(String(bNum));
            }
            return sortState.ascending ? result : -result;
        }
        return 0;
    });

    // Re-append rows in sorted order
    rows.forEach(row => tbody.appendChild(row));

    // Update sort indicators
    const sortHostname = document.getElementById('sort-hostname');
    const sortIp = document.getElementById('sort-ip');
    if (sortHostname && sortIp) {
        sortHostname.innerHTML = '▲▼';
        sortIp.innerHTML = '▲▼';
        sortHostname.classList.remove('active');
        sortIp.classList.remove('active');

        const activeIndicator = document.getElementById('sort-' + sortBy);
        if (activeIndicator) {
            activeIndicator.innerHTML = sortState.ascending ? '▲' : '▼';
            activeIndicator.classList.add('active');
        }
    }
}
</script>
{% endblock %}
